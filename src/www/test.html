<!DOCTYPE html>
<html>
    <head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
        
		<title>STT-Server</title>
		<link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
		<link rel="stylesheet" href="main.css">
		
		<!-- SEPIA Web Audio Lib -->
		<script type="text/javascript" src="sepia-web-audio.min.js?v=0.9.5"></script>
		<script type="text/javascript" src="sepia-recorder.js"></script>
		<script>
			//set correct modules folder
			SepiaFW.webAudio.defaultProcessorOptions.moduleFolder = "audio-modules";
		</script>
		
		<style>
		</style>
    </head>
    <body>
		<div class="page">
			<h1><button onclick="backToRoot()" style="margin: 0 16px 0 0; border-radius: 15px;">&#8249;</button>SEPIA STT Server - Test Page 1</h1>
			<p>This is the test page for the SEPIA STT server (V2). Use the microphone to record audio then connect to the server and stream the last recording to get the transcription.</p>
			<p>More advanced demos can be found here: <a href="https://sepia-framework.github.io/app/index.html" target=_blank>SEPIA Client</a> and here: <a href="https://github.com/SEPIA-Framework/sepia-web-audio" target=_blank>SEPIA Web Audio Lib</a></p>
			<h2>Recorder</h2>
			<div class="section">
				<div class="group"><label>Start/Stop:</label><button id="micButton" onclick="toggleMic();"></button></div>
				<div class="group"><label>Gain:</label><input id="microphoneGain" class="small" type="number" value="1.0"></div>
				<div class="group"><label>Vol. Meter (green = good):</label><div id="volumeMeter"><div id="volumeBar"></div></div></div>
			</div>
			<div class="section">
				<div class="group"><label>Source Info:</label><span id="recoderInfo" style="flex: 1 1 auto;">-updated during rec.-</span></div>
			</div>
			<h2>Connection</h2>
			<div class="section">
				<div class="group"><label>Client-ID:</label><input type="text" id="clientId" autocomplete="off" value="any"/></div>
				<div class="group"><label>Access Token:</label><input type="text" id="accessToken" autocomplete="off" value="test1234"/></div>
			</div>
			<div class="section">
				<div class="group">
					<label>Settings:</label>
					<button onclick="getServerInfo()">RELOAD</button>
					<label>Language:</label><select id="languageSelect"><option selected>-?-</option></select>
					<label>Engine:</label><span id="asrEngine">-?-</span>
					<label>Features:</label><span id="asrFeatures">-?-</span>
				</div>
				<div class="group">
					<label>Tests:</label>
					<button onclick="openConnection()">OPEN</button>
					<button onclick="sendWelcome()">SEND WELCOME</button>
					<button onclick="sendMessage('test');">TEST MESSAGE</button>
					<button onclick="sendBytes()">STREAM LAST RECORDING</button>
					<button onclick="closeConnection()">CLOSE</button>
				</div>
			</div>
			<h2>Messages <button onclick="clearMessages()" style="margin: 0 8px;">CLEAR</button></h2>
			<!--<div class="section">
				<div class="group" style="flex: 1 1 auto;">
					<label>Message:</label>
					<input type="text" id="messageText" autocomplete="off"/>
					<button onclick="sendTextFromIput()">Send</button>
				</div>
			</div>-->
			<div>
				<ul id='messages'>
					<li>Log:</li>
				</ul>
			</div>
		</div>
        <script>
			//--- Navigation ---

			function backToRoot(){
				location.href = location.origin;
			}

			//--- Recorder ---
			
			var volumeThresholds = [0.05, 10];		//too low/too high
			var gainNode = document.getElementById("microphoneGain");
			
			var isLoading = false;
			var isRecording = false;
			var waveBuffering = false;
			var lastRecording;
			
			function toggleMic(){
				if (!isLoading && !isRecording){
					isLoading = true;
					setMicState("loading");
					//for this demo we create a new recorder each time
					SepiaVoiceRecorder.stopAndReleaseIfActive(function(){
						SepiaFW.webAudio.tryNativeStreamResampling = false;		//try native resampling?
						SepiaVoiceRecorder.create({
							gain: +gainNode.value,
							//fileUrl: "test-audio/hallo_dies_ist_ein_test.wav",
							//recordingLimitMs: 10000
						});
					});
					
				}else if (isRecording){
					SepiaVoiceRecorder.stop();
				
				}else if (isLoading){
					isLoading = true;
					setMicState("loading");
					SepiaVoiceRecorder.stopAndReleaseIfActive(function(){
						isLoading = false;
						isRecording = false;
						setMicState("idle");
					});
				}
			}
			function onMicError(){
				setMicState("error");
				isRecording = false;
				isLoading = false;
			}
			
			SepiaVoiceRecorder.onProcessorReady = function(info){
				console.log("SepiaVoiceRecorder -  onProcessorReady", info);
				document.getElementById("recoderInfo").textContent = "Sample-rate: " + info.targetSampleRate 
					+ "Hz (rf:" + (info.inputSampleRate/info.targetSampleRate) + ") - Label: " + (info.sourceInfo? info.sourceInfo.label : "");
				setMicState("idle");
				isLoading = false;
				isRecording = false;
				waveBuffering = false;
				SepiaVoiceRecorder.start();
			}
			SepiaVoiceRecorder.onProcessorInitError = function(err){
				console.error("SepiaVoiceRecorder -  onProcessorInitError", err);
				onMicError();
				addMessage("ERROR - onProcessorInitError: " + err.message);
				if (location.protocol == "http:" && !location.origin.indexOf("http://localhost") == 0){
					document.getElementById("recoderInfo").textContent = "Init. ERROR - Likely because of insecure origin (no HTTPS or localhost)";
				}else{
					document.getElementById("recoderInfo").textContent = "Init. ERROR - " + err.message;
				}
			}
			SepiaVoiceRecorder.onProcessorError = function(err){
				console.error("SepiaVoiceRecorder -  onProcessorError", err);
				onMicError();
				addMessage("ERROR - onProcessorError: " + err.name);
			}

			SepiaVoiceRecorder.onAudioStart = function(info){
				console.log("SepiaVoiceRecorder -  onAudioStart");
				isRecording = true;
				setMicState("recording");
				addMessage("Microphone is OPEN");
			}
			SepiaVoiceRecorder.onAudioEnd = function(info){
				console.log("SepiaVoiceRecorder -  onAudioEnd");
				isRecording = false;
				setMicState("idle");
				addMessage("Microphone is CLOSED");
			}

			SepiaVoiceRecorder.onProcessorRelease = function(info){
				console.log("SepiaVoiceRecorder -  onProcessorRelease");
				setMicState("idle");
				isRecording = false;
				isLoading = false;
			}

			SepiaVoiceRecorder.onDebugLog = function(msg){}
			
			SepiaVoiceRecorder.onResamplerData = function(data){
				//console.log("SepiaVoiceRecorder -  onResamplerData", data.rms);
				setVolume(data.rms);
			}
			SepiaVoiceRecorder.onWaveEncoderStateChange = function(state){
				if (state.isOpen == true){
					if (!waveBuffering) addMessage("WAV Recorder - Started capturing");
					waveBuffering = true;
				}else if (state.isOpen === false){
					if (waveBuffering){
						addMessage("WAV Recorder - Stopped capturing (Note: this happens when mic. closes or 500KB capture limit is reached ~ 16s)");
					}
					waveBuffering = false;
				}
			}
			SepiaVoiceRecorder.onWaveEncoderAudioData = function(waveData){
				//console.log("SepiaVoiceRecorder -  onWaveEncoderAudioData", waveData);
				lastRecording = waveData;
				var targetEle = addMessage("WAV Result:");
				SepiaVoiceRecorder.addAudioElementToPage(targetEle, waveData, "audio/wav");
			}

			//--- Server ---

			var languageCode = "";

			function handleServerSettings(settings){
				if (settings.version){
					addMessage("INFO - Server version: " + settings.version);
				}
				if (settings.engine){
					addMessage("INFO - Active engine: " + settings.engine);
					document.getElementById("asrEngine").textContent = settings.engine;
				}
				if (settings.languages){
					languageSelector.innerHTML = "";
					settings.languages.forEach(function(lc, i){
						var opt = document.createElement("option");
						opt.textContent = lc;
						opt.value = lc;
						if (i=0){
							opt.selected = true;
							languageCode = lc;
						}
						languageSelector.appendChild(opt);
					});
					addMessage("INFO - Available ASR languages: " + JSON.stringify(settings.languages, null, 2));
					if (settings.models){
						languageSelector.title = JSON.stringify(settings.models, null, 2);
						addMessage("INFO - Available ASR models: " + JSON.stringify(settings.models, null, 2));
					}
				}
				if (settings.features){
					document.getElementById("asrFeatures").textContent = settings.features;
				}
			}
			function setLanguage(newLang){
				languageCode = newLang;
			}

			var languageSelector = document.getElementById("languageSelect");
			languageSelector.addEventListener("change", function(e){
				setLanguage(languageSelector.value);
			});

			//--- HTTP ---

			function getServerInfo(){
				addMessage("INFO - Loading server settings...");
				fetch(location.origin + "/settings", {
					method: "GET"
				}).then(function(res){
					if (res.ok){
						return res.json();
					}else{
						throw {"name": "FetchError", "message": res.statusText, "code": res.status};
					}
				}).then(function(json){
					console.log("Server Info", json);
					if (json && json.settings){
						handleServerSettings(json.settings);
					}
				}).catch(function(err){
					console.error("Server Info Fetch ERROR", err);
				});
			}
			function pingServer(successCallback, errorCallback){
				fetch(location.origin + "/ping")
				.then(function(res){ return res.json(); })
				.then(function(json){
					console.log("Ping", json);
					if (successCallback) successCallback(json);
				})
				.catch(function(err){
					console.error("Ping", err);
					if (errorCallback) errorCallback(err);
				});
			}
		
			//--- WebSocket ---
			
			var protocol = (location.protocol == "https:")? "wss://" : "ws://";
			var socketHost = protocol + location.host;
			var ws;

			var msgId = 0;
			
			function openConnection(){
				ws = new WebSocket(socketHost);
				
				ws.onopen = function(){
					addMessage("Connection OPEN");
				}
				
				ws.onclose = function(){
					addMessage("Connection CLOSED");
				}
				
				ws.onmessage = function(event){
					if (event && event.data && typeof event.data == "string"){
						try {
							handleSocketMessage(JSON.parse(event.data));
						}catch(err){
							addMessage("ERROR - message handler saw invlaid JSON? " + err.name);
						}
					}
				}
				
				ws.onerror = function(error){
					handleSocketError(error);
				}
			}

			function closeConnection(){
				if (ws && ws.readyState == ws.OPEN) ws.close();
			}
            			
			function handleSocketMessage(msgJson){
				if (msgJson.type == "error"){
					handleSocketError(msgJson);
				}else{
					addMessage(JSON.stringify(msgJson));	//DEBUG
					if (msgJson.type == "ping"){
						//TODO: send only after welcome
						sendJson({type: "pong", msg_id: msgJson.msg_id});
					}
				}
			}
			function handleSocketError(err){
				var msg = (err && err.name)? (err.name + " - " + (err.message || "?")) : "?";
				addMessage("ERROR: " + msg);
				//Errors are not acceptable :-p - close in any case
				closeConnection();
			}

			function sendJson(json){
				if (ws && ws.readyState == ws.OPEN){
					ws.send(JSON.stringify(json));
				}else{
					addMessage("INFO: Connection is closed");
				}
			}
			function sendBytes(){
				if (!lastRecording){
					addMessage("INFO: Record audio first");
					return;
				}
				if (!ws || !ws.readyState == ws.OPEN){
					addMessage("INFO: Open connection first");
					return;
				}
				var orgLength = lastRecording.byteLength;
				console.log("Sending approx. " + Math.round(orgLength/2/16000) + "s of audio in chunks of 512 (16bit)");
				var n = Math.floor(orgLength/2/512);
				var rest = orgLength - (n*2*512);
				var totalSent = 0;
				var chunks = [];
				for (let i=0; i<(orgLength - rest); i+=1024){
					chunks.push(lastRecording.buffer.slice(i, i + 1024));
				}
				chunks.push(lastRecording.buffer.slice(n*1024, n*1024 + rest));
				var sentN = 0;
				var completeCallback = function(){
					console.log("Sent " + totalSent + " of " + orgLength + " bytes");	//DEBUG
					sendAudioEnd(orgLength);
				};
				chunks.forEach(function(b, j){
					//we don't want to send all at once ...
					setTimeout(function(){
						if (ws && ws.readyState == ws.OPEN){
							ws.send(b);
							totalSent += b.byteLength;
						}
						sentN++;
						if (sentN >= chunks.length){
							//console.log("sent " + j, b.byteLength);	//DEBUG
							completeCallback();
						}
					}, j*15);
				});
			}
			function sendMessage(text){
				sendJson({
					"type": "chat",
					"data": {"text": text},
					"msg_id": ++msgId
				});
			}
			function sendWelcome(text){
				var clientId = document.getElementById("clientId");
				var accessToken = document.getElementById("accessToken");
				sendJson({
					"type": "welcome",
					"data": {
						"language": languageCode
					},
					"client_id": clientId.value,
					"access_token": accessToken.value,
					"msg_id": ++msgId
				});
			}
			function sendAudioEnd(byteLength){
				sendJson({
					"type": "audioend",
					"data": {"byteLength": byteLength},
					"msg_id": ++msgId
				});
			}
			
			//--- Messages and animations ---

			var textInputElement = document.getElementById("messageText");
			if (textInputElement){
				textInputElement.addEventListener("keyup", function(event){
					if (event.key === "Enter"){
						sendTextFromIput(this);
					}
				});
				function sendTextFromIput(input){
					if (!input) input = textInputElement;
					sendMessage(input.value);
					input.value = "";
				}
			}
			
			var messages = document.getElementById('messages');
			function addMessage(msg){
				var message = document.createElement('li');
				message.textContent = new Date().toLocaleTimeString() + " - " + msg;
				messages.appendChild(message);
				messages.scrollTop = messages.scrollHeight;
				return message;
			}
			function clearMessages(){
				messages.innerHTML = "<li>Log:</li>";
			}
			var maxLogHeight = Math.ceil(window.innerHeight - messages.getBoundingClientRect().top - 58);
			if (maxLogHeight > 150){
				messages.style.height = maxLogHeight + "px";
			}
			
			var volumeBar = document.getElementById("volumeBar");
			var volBarPassedCheck = false;
			var maxVol = 0.02;
			function setVolume(val){
				if (!volBarPassedCheck){
					if (val < volumeThresholds[0] || val > volumeThresholds[1]){
						volumeBar.style.background = "#f04";	//bad
					}else{
						volumeBar.style.background = "#0f4";	//good
						volBarPassedCheck = true;
						setTimeout(function(){ volBarPassedCheck = false; }, 2000);
					}
				}
				if (val > maxVol) maxVol = val;
				volumeBar.style.width = Math.round(val/maxVol * 100) + "%";
			}

			var micButton = document.getElementById("micButton");
			function setMicState(state){
				micButton.classList.remove("recording", "loading");
				if (state == "loading"){
					micButton.classList.add("loading");
				}else if (state == "recording"){
					micButton.classList.add("recording");
				}else{
					//idle
				}
			}

			// ON READY
			
			setVolume(0);
			setMicState("idle");
			getServerInfo();

        </script>
    </body>
</html>